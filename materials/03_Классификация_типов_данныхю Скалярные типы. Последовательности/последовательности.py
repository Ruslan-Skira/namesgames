dsstr_1 = 'some string '
str_2 = 'some string2 '

len(str_1)  # вернет длину строки => 11
str_result = str_1 + str_2  # конкатенация - склеивание. Возвращает новый объект.
multiple_str = str_1 * 2  # повторяющуюся несколько раз  => 'some string some string '

max(str_1)  # вернет найбольшее значение => 't';
min(str_1)  # вернет найменьшее значение => ' '

# При работе со строкой сравнивает порядковый номер символа,
# который получает с помощью функции ord(some_symbol)


is_included = 'some' in str_1  # проверяет вхождение

# Индексация и срезы
n = 0
el_0 = str_1[n]  # => получить n элемент последовательности. В данном случае выведет 's'

start = 0
finish = 5
from_el_0_to_el_5 = str_1[start: finish]
# получить последовательность с элемента start, ДО элемента finish, не включая него

# так же можно делать срезы последовательности с определенным шагом.
start = 0
finish = 8
step = 2
from_el_0_to_el_8_in_steps2 = 'some string '[start:finish:step]  # => 'sm t'

# при этом срезы всегда возвращают новый объект!
copy_of_str_1 = str_1[:]  # вот один из способов копирования последовательностей. Но помните о кэшировании строк!

# так же можно вести обратную индексацию, или использовать отрицательный шаг
str_1_reverse = str_1[::-1]  # => ' gnirts emos'
str_1_with_negative_index = str_1[-8::-1]  # =>' emos'


start = -2
finish = 0
from_el_minus2_to_el_0 = 'some string '[start:finish]


# методы
str_1.count('some')  # Возвращает количество вхождений элементов в последовательность => 1
str_1.count('s')  # Возвращает количество вхождений элементов в последовательность => 2

start = 3
finish = -1
index_el: int = str_1.index(' s', start, finish)

# Индексы

#  +---+---+---+---+---+---+
#  | P | y | t | h | o | n |
#  +---+---+---+---+---+---+
#    0   1   2   3   4   5
#   -6  -5  -4  -3  -2  -1

# Срезы
#  +---+---+---+---+---+---+
#  | P | y | t | h | o | n |
#  +---+---+---+---+---+---+
#  0   1   2   3   4   5   6
# -6  -5  -4  -3  -2  -1
